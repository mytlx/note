# 自动内存管理机制

自动内存管理可以归结为自动化地解决了两个问题：

* 给对象分配内存
* 回收分配给对象的内存

## 一、运行时数据区域

<img src="http://img1.coin163.com/00/62/JBRRJf.png" alt="运行时数据区" width="90%"></img>

### 1. 程序计数器

**程序计数器（Program Counter Register）**是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。

java虚拟机的**多线程**通过**线程轮流切换并分配处理器执行时间**的方式实现的。

为了线程切换后能回复到正确的执行位置，**每条线程都需要一个独立的程序计数器**，各条线程之间计数器互不影响，独立存储，这类内存区域称为**“线程私有“的内存**。

* 如果线程正在执行的是一个**Java方法**，PC记录的是正在执行的**虚拟机字节码指令的地址**。
* 如果正在执行的**Native方法**，PC值为**空（Undefined）**。
* 此内存区域是**唯一**一个在jvm规范中**没有规定任何OutOfMemoryError**情况的区域。



### 2. Java虚拟机栈

**Java虚拟机栈（Java Virtual Machine Stacks）**也是**线程私有**的，**生命周期与线程相同**。

虚拟机栈描述的是**Java方法执行的内存模型**：

* 每个方法在执行的同时都会创建一个**栈帧（Stack Frame）**，用于<u>存储局部变量表</u>、<u>操作数栈</u>、<u>动态链接</u>、<u>方法出口</u>等信息。
  * 局部变量表存放了编译期可知的各种**基本数据类型**（8种）、**对象引用**（reference类型，不等同于对象和本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）、**returnAddress类型**（指向了一条字节码指令的地址）
  * 其中**64位**长度的**long**和**double**类型的数据会占用**2个局部变量空间（slot）**，其余的数据类型占用1个
  * 局部变量表所需的**内存空间在编译期间完成分配**，在方法运行期间不会改变局部变量表的大小

* 每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中的入栈到出栈的过程。

jvm规范中，对这个区域规定了两种异常情况：

* 如果线程请求的栈深度大于虚拟机所允许的深度，就抛出	StackOverflowError异常
* 如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常



### 3. 本地方法栈

​	本地方法栈（Native Method Stack）与虚拟机栈作用类似。

* **虚拟机栈**为虚拟机执行**Java方法（字节码）**服务，而**本地方法栈**为虚拟机使用到的**Native方法**服务

* 与虚拟机栈一样，本地方法栈也会抛出**StackOverflowError**和**OutOfMemoryError**异常

有的虚拟机（Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。



### 4. Java堆

Java堆（Java Heap）是Java虚拟机所管理的内存中**最大**的一块。

* 所有**线程共享**
* 唯一目的是存放对象实例，**所有的对象实例以及数组都要在堆上分配**
* 垃圾收集器管理的主要区域，所以也被称为**GC堆（Garbage Collection Heap）**

由于垃圾收集器都采用分代收集算法，所以java堆还可以细分为：

* 新生代
* 老年代

新生代进一步细分：

* Eden空间
* From Survivor空间
* To Survivor空间

从内存分配的角度，还可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer， TLAB）。

* 存于Eden空间

jvm规范：java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。

* 既可以实现成固定大小的，也可以是可扩展的。

* 主流的虚拟机都是按照**可扩展**来实现的（通过-Xmx和-Xms控制）。

如果堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。



### 5. 方法区（Method Area）

* 线程共享
* 用于存储已被虚拟机加载的**类信息**、**常量**、**静态变量**、**即时编译器编译后的代码**等数据

虽然jvm规范把方法区描述为堆的一个逻辑部分，但是有个别名叫**Non-Heap（非堆）**，目的应该是与Java堆区分开来。

jvm规范对方法区的限制非常宽松：

* 不需要连续的内存
* 可以选择固定大小或者可扩展
* 可以不实现垃圾收集
  * 这区域的内存回收目标是**常量池的回收**和**对类型的卸载**

当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。



### 6. 运行时常量池

运行时常量池（Runtime Constant Pool）是**方法区的一部分**。

Class文件中有一项信息就是常量池（Constant Pool Table），用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池存放。

运行时常量池相对于Class文件常量池的另一个重要特征就是具备**动态性 **，Java语言并不要求常量一定只有编译器才产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，	运行期间也可能将新的常量放入池中，例如String类的intern方法

当常量池无法再申请到内存时会抛出OutOfMemoryError异常。



### 7. 直接内存

直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存被频繁的使用，也可能导致OutOfMemoryError异常。

在JDK 1.4新加入NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。避免了在Java堆和Native堆中来回复制数据。



## 二、HotSpot对象

### 1. 对象的创建

1. 遇到new指令时，进行类加载检查

   * 检查这个指令的参数是否能在常量池中定位到那个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，必须先执行相应的类加载过程。

2. 为新生对象分配内存

   1. 指针碰撞（Bump the Pointer）
      * 假设Java堆中的内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。
   2. 空闲列表（Free List）
      * 如果Java中的内存不是规整的，已使用过的内存和空闲的内存想相互交错，虚拟机必须维护一个列表，记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录

   * 选择哪种分配方法由Java堆是否规整决定，而Java堆是否规整又由所采用的的垃圾收集器是否带有压缩整理的功能决定。

3. 两种方案解决内存分配时的线程安全问题

   1. 对分配内存空间的动作进行同步处理
   2. 把内存分配的动作按照线程划分在不同空间之中进行，本地线程分配缓冲（TLAB）

4. 虚拟机对对象进行必要的设置

5. 一般来说，执行new指令之后会接着执行\<init\>方法，把对象按照程序员的意愿进行初始化。



### 2. 对象的内存布局

3块区域：对象头（Header）、实例数据（Instance Data）、对齐填充（Padding）

1. 对象头：包含两部分信息
   1. Mark Word：用于存储对象自身的运行时数据
   2. 类型指针：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
2. 实例数据部分
   * 对象真正存储的有效信息，程序代码中所定义的各种类型的字段内容
   * 存出顺序会受到**虚拟机分配策略参数（FieldsAllocationStyle）**和**字段在Java源码中定义的顺序**的影响
3. 对齐填充
   * 不是必需的，也没有特别的含义，仅仅起着占位符的作用
   * 对象的大小必须是8字节的整数倍，对象头正好是8字节的整数倍（1倍或2倍），当对象实例部分未对齐，需要对齐填充来补全。



### 3. 对象的访问定位

1. 句柄访问
   * java堆中会划分出一块内存来作为句柄池，reference中存储的是对象的句柄地址，而句柄中包含了对象实例数据域类型数据各自的具体地址信息。
   * 优点：reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。
2. 直接指针访问：Sun HotSpot采用
   * reference中存储的直接就是对象地址。
   * 优点：速度更快，节省了一次指针定位的时间开销。



## 三、对象是否死亡

### 1. 引用计数算法

给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。

很难解决对象间相互循环引用的问题。

### 2. 可达性分析算法（Reachability Analysis）

通过一系列的称为”GC Roots“的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时（从GC Roots到这个对象不可达），证明此对象不可用，将被判定为是可回收的对象。

Java中，可作为GC Roots的对象包括下面几种：

* 虚拟机栈（栈帧中的本地变量表）中引用的对象
* 方法区中类静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈JNI（Native方法）引用的对象



### 3. 引用

判定对象是否存活都与引用有关。

JDK 1.2之前，Java中的引用定义：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。

这种定义下对象只有被引用和没有被引用两种状态。

还有一种对象：当内存空间还足够时，则能保留在内存之中；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。

引用分为**强引用（Strong Reference）**、**软引用（Soft Reference）**、**弱引用（Weak Reference）**、**虚引用（Phantom Reference）**4种，引用强度依次减弱：

* **强引用**就是指程序代码中普遍存在的
  * 只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。
* **软引用**描述一些还有用但并非必需的对象
  * 对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果回收之后内存还是不够，才会抛出内存溢出异常
* **弱引用**描述非必需对象，强度比软引用更弱一些
  * 被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象
* **虚引用**也称**幽灵引用**或者**幻影引用**，最弱的一种引用关系
  * 为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知



### 4. 生存还是死亡

### 5. 回收方法区



## 四、垃圾收集算法

### 1. 标记 - 清除算法（Mark-Sweep）

算法分为**标记**和**清除**两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

不足：

* 效率问题：标记和清除两个过程的效率都不高
* 空间问题：标记清除后会产生大量不连续的内存碎片，分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作

### 2. 复制算法（Copying）

将可用内存按容量划分为大小相等的两块，每次只是用其中的一块。当这一块的内存用完了，就将还存活着的对象赋值到另外一块上面，然后再把已使用过的内存空间一次清理掉。

优点：

* 每次都是对整个半区进行内存回收，不用考虑内存碎片等，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。

缺点：

* 代价是将内存缩小为原来的一半，未免太高了些。
* 对象存活率较高时，需要较多的复制操作，效率将会变低，老年代一般不能直接选用这种算法

该算法用来**回收新生代**，由于新生代中的对象98%是“朝生夕死”，所以不需要按照1:1的比例划分内存空间。

将内存划分为**一块较大的Eden空间**和**两块较小的Survivor空间**

* 每次使用Eden和其中一块Survivor，当回收时，将Eden和Survivor中还存活的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。

* Hospot虚拟机默认Eden和Survivor的大小比例是8：1
* 当Survivor空间不够用时，需要依赖其他内存（老年代）进行**分配担保（Handle Promotion）**
  * 如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象，这些对象将直接通过分配担保机制进入老年代

### 3. 标记 - 整理算法（Mark-Compact）

标记过程与“标记-清除”算法一样，之后让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

适用于老年代。

### 4. 分代收集算法（Generational Collection）

现在虚拟机垃圾回收都采用分代收集算法，根据对象存活周期的不同将内存划分为几块，根据各个年代的特点采用适当的收集算法。

一般将Java堆分为：

* 新生代
  * 每次垃圾收集时都发现有大批对象死去，只有少量存活
  * **复制算法**
* 老年代
  * 对象存活率高，没有额外的空间对它进行分配担保
  * **标记 - 清理**或**标记 - 整理**



## 五、HotSpot的算法实现

### 1. 枚举根节点

### 2. 安全点

### 3. 安全区域



## 六、垃圾收集器

### 1. Serial 收集器

### 2. ParNew 收集器

### 3. Parallel Scavenge 收集器

### 4. Serial Old 收集器

### 5. Parallel Old 收集器

### 6. CMS 收集器

### 7. G1收集器

### 8. 理解GC日志

### 9. 垃圾收集器参数总结



## 七、内存分配与回收策略

对象的内存分配，

