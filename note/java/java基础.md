# java基础

## 数据类型

8种基本类型（primitive type）：

* 4种整型
  * byte
  * short
  * int
  * long
* 2种浮点类型
  * float
  * double
* 1种用于表示Unicode编码的字符单元的字符类型char
  * char
* 一种用于表示真值的boolean类型
  * boolean

### 整型

| 类型  | 存储需求 |                        取值范围                         |
| :---: | :------: | :-----------------------------------------------------: |
|  int  |  4字节   |     - 2 147 483 648 ~ 2 147 483 647（正好超过20亿）     |
| short |  2字节   |                    - 32 768 ~ 32 767                    |
| long  |  8字节   | - 9 223 372 036 854 775 808 ~ 9 223 372 036 854 775 807 |
| byte  |  1字节   |                       - 128 ~ 127                       |

* int类型最常用
* java中，所有的数值类型所占据的字节数量与平台无关
* 长整型数值有一个后缀L或l（如`40000000000L`）
* 十六进制前缀0x或0X，八进制前缀0，如 010 对应八进制的8，容易混淆，不建议使用
* java 7 开始，加上前缀0b或0B表示二进制，还可以为数字字面量加下划线，更易读（如 `0b1111_0100_0010_0100_0000` 或 `1_000_000`表示一百万），java编译器会去掉这些下划线
* java没有任何无符号形式的整型

### 浮点类型

|  类型  | 存储需求 |                         取值范围                          |
| :----: | :------: | :-------------------------------------------------------: |
| float  |  4字节   |      大约 +- 3.402 823 47E+38F（有效位数为 6~7 位）       |
| double |  8字节   | 大约 +- 1.797 693 134 862 315 70E+308（有效位数为 15 位） |

* 绝大部分程序采用double类型
* float类型的数值有一个后缀F或f，没有后缀F的浮点数值默认为double类型，也可以有后缀D或d
* 所有浮点数值计算都遵循 IEEE 754 规范，表示溢出和出错的三个特殊的浮点数值
  * 正无穷大：`Double.POSITIVE_INFINITY`
  * 负无穷大：`Double.NEGATIVE_INFINITY`
  * NaN（Not a Number）：`Double.NaN`
    * 不能检测一个特定值是否等于 `Double.NaN`
    * 可以使用 `Double.isNaN()`方法

### char类型

* char类型的字面量值要用单引号括起来
* 值可以表示为十六进制值，范围从 \u0000 到 \Uffff
* char类型描述了 UTF-16编码中的一个代码单元

### boolean类型

* 两个值：false 和 true
* **整型值和布尔值之间不能进行相互转换**



## 变量

* 声明一个变量之后，必须用赋值语句对变量进行显示初始化
* 在java中可以将声明放在代码中的任何地方
* 变量的声明尽可能地靠近变量第一次使用的地方
* 不区分变量的声明与定义



## 常量

* 利用关键字 **final**指示常量
  * 只能被赋值一次
  * 一旦赋值之后，就不能再更改了
  * 常量名使用全大写

* 利用关键字 **static final**设置一个类常量
  * 定义位于方法外部



## 类型转换

两个不同数值类型进行二元操作时，先要将两个操作数类型转换为同一种类型，然后再进行计算：

* 如果两个操作数中的一个是double类型，另一个操作数就会转换为double类型
* 否则，如果其中一个操作数是float类型，另一个操作数将会转换为float类型
* 否则，如果其中一个操作数是long类型，另一个操作数将会转换为long类型
* 否则，两个操作数都将被转换为int类型



## 位操作

`>>>`运算符会用0填充高位，`>>`运算符用符号位填充高位，不存在 `<<<`运算符



## 字符串

* java字符串就是**Unicode字符序列**
* java没有内置的字符串类型，而是在标准java类库中提供了一个预定义类
* 每个用双引号括起来的字符串都是String类的一个实例
* 不能修改java字符串中的字符，String类对象称为**不可变字符串**
  * 编译器可以让字符串共享
  * 通常只有字符串常量是共享的，而 `+` 或 `substring` 等操作产生的结果并不是共享的

### 子串

`substring(start, end);` 左闭右开

### 拼接

* java使用 `+` 号连接两个字符串
* 当一个字符串与一个非字符串的值进行拼接时，后者被转换成字符串
* `String.join()`方法可以实现多个字符串拼接，用一个定界符分隔
  * `String.join("/", "S", "M", "L");` => `S/M/L`

### 检测相等

* `s.equals(t)` 检测两个字符串是否相等
* `s.equalsIgnoreCase(t)` 检测两个字符串是否相等，不区分大小写
* `s.compareTo(t)` s在t前返回负值，相等返回0，s在t后返回正值
* 一定不要使用 `==`检测两个字符串是否相等，只能检测是否放在同一个位置


### 空串和Null串

* 空串 `“”` 是长度为0的字符串
  * 是一个java对象，有自己的**串长度（0）**和**内容（空）**
* null串表示目前没有任何对象与该变量关联
  * `if (str == null)` 检测一个字符串是否为null



## 控制流程

### 块作用域

块（即复合语句）：由一对大括号括起来的若干条简单的java语句

* 块确定了变量的作用域

* 一个块可以嵌套在另一块中

* **不能再嵌套的两个块中声明同名的变量，否则无法编译**

  ```java
  public static void main(String[] args){
      int n;
      //...
      {
          int k;
          int n;    // Error
          //...
      }
  }
  ```

### switch语句

case标签：

* 类型为 char， byte， short 或 int 的常量表达式
* 枚举常量
* 字符串字面量（java 7开始）

### 中断控制流程语句

java设计者将goto作为保留字，但实际上并没有打算在语言中使用它。

但是提供了一种 **带标签的break语句**，用于跳出多重嵌套的循环语句

* 标签必须放在希望跳出的最外层循环之前，并且必须紧跟一个冒号

  ```java
  Scanner in = new Scanner(System.in);
  int n;
  read_data:
  while(...){
      //...
      for(...){
          System.out.print("...");
          n = in.nextInt();
          if (n < 0)
              break read_data;
          // ...
      }
  }
  // this statement is executed immediately after the labeled break
  ...
  ```

* 可以将标签应用到任何语句中，甚至可以应用到if语句或者块语句中
* 只能跳出语句块，而不能跳入语句块



## 数组

数组是一种数据结构，用来存储同一类型值的集合。

两种形式声明数组：

* `int[] a;` 建议使用
* `int a[];`

声明数组后，并没有将a初始化为一个真正的数组，应该使用**new运算符**创建数组。

```java
int[] a = new int[100];
```

这条语句创建了一个可以存储100个整数的数组。

数组长度**不要求是常量**：`new int[n]`会创建一个长度为n的数组。

创建一个数组时：

* 数字数组的所有元素会初始化为0
* boolean数组的元素会初始化为false
* 对象数组的元素会初始化为null

** 数组一旦创建了，就不能再改变它的大小。**

创建数组对象并同时赋予初始值的简化书写形式，不需要调用new

```java
int[] a = { 2, 3, 4, 5, 6, 7 };
```

初始化一个**匿名数组**

```java
new int[] { 11, 12, 13, 14, 15, 16};
```

* 数组的大小就是初始值的个数
* 可以在不创建新变量的情况下重新初始化一个数组
* 允许数组长度为0， 数组长度为0和null不同
* java数组没有指针运算，不能通过 `数组名+1` 得到数组的下一个元素



`a.length` 

* 获得数组中的元素个数

`Arrays.toString(type[] a)` 

* 打印数组中的所有值

`Arrays.copyOf(type[] a, int length)` 

* 将一个数组的所有值拷贝到一个新数组中去，通常用于增加数组的大小

`Arrays.sort(type[] a)`

* 对数组进行排序，使用了**优化的快速排序**算法  



## 对象与类

* 实例域（instance field）：对象中的数据
* 状态（state）：对于每个特定的类实例（对象）都有一组特定的实例域值，这些值的集合就是和这个对象的当前状态

### 类之间的关系

* 依赖（uses-a）：一个类的方法操纵另一个类的对象
* 聚合（has-a）：类A的对象包含类B的对象
* 继承（is-a）：A继承B

### 对象变量与对象

```java
Date birthday = new Date();
```

birthday是对象变量，new Date() 构造了一个新对象

* 对象变量并没有实际包含一个对象，而仅仅引用一个对象
* 任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new操作符的返回值也是一个引用
* 显式地将对象变量设置为null，表示这个对象变量没有引用任何对象
* 局部变量不会自动地初始化为null，而必须通过调用new或将它们设置null进行初始化
* **所有的java对象都存储在堆中，所有的java对象都是在堆中构造的**





### 用户自定义类

* 文件名必须与public类的名字相匹配
* 在一个源文件中，只能有一个公有类，但可以有任意数目的非公有类

### 构造器

* 构造器与类同名
* 每个类可以有一个以上的构造器
* 构造器可以有0个、1个或多个参数
* 构造器没有返回值
* 构造器总是伴随着new操作一起调用
* 不要在构造器中定义与实例域重名的局部变量



## final实例域

* 构建对象时必须初始化这样的域
* 初始化后不能再对它进行修改
* 大都应用于**基本类型域**或**不可变类的域**
  * 可变的类使用final会造成混乱
  * final关键字只是表示对象变量不会再引用其他对象，但是这个对象可以更改



## 静态域

* 也称为类域
* 所有对象共享
* 属于类而不属于任何对象



## 静态常量

* 例如：`public static finale double PI = 3.14145926535897323846;`
* 可以通过类名直接获取，`Math.PI`
* 由于每个类对象都可以对公有域进行修改，所以不建议将域设计为public，但是final域却没问题，因为声明为final不可修改



## 静态方法

* 不能向对象实施操作的方法
* static是类方法，不属于某一个对象
* 没有this参数，this和super都是指向对象
* 不能访问实例域，可以访问自身类中的静态域
* 使用类名调用方法，也可以使用类下对象调用，但是不建议
* 使用静态方法的情况
  * 一个方法不需要访问对象状态，所需参数都是通过显示参数提供
  * 只需要访问类的静态域



## main方法

* 不对任何对象进行操作
  * 在启动程序时还没有任何一个对象，静态的main方法将执行并创建程序所需要的对象
* 每个类都可以有一个main方法，可以用于单元测试



## 方法参数

> 按值调用（call by value）：表示方法接收的是调用者提供的值
>
> 按引用调用（call by reference）：表示方法接收的是调用者提供的变量地址
>
> 一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值

* java采用**按值调用**
  * 方法不能修改传递给它的任何参数变量的内容
* 方法参数的类型
  * 基本数据类型（数字、布尔型）
  * 对象引用（按值传递）
* 方法参数的使用情况
  * 一个方法不能修改一个基本数据类型的参数（数值、布尔）
  * 一个方法可以改变一个对象参数的标志
  * 一个方法不能让对象参数引用一个新的对象



## 重载（overloading）

* 方法的**签名（signature）**
  * **方法名、参数类型**
  * **不包含返回类型**
* 多个方法有相同的名字、不同的参数，便产生重载
  * 也就是说重载需要签名不同，只是返回类型不同不算重载
* 重载解析（overloading resolution）
  * 编译器通过**各个方法给出的参数类型**与**特定方法调用所使用的值类型**进行匹配来挑选相应的方法，如果找不到匹配的参数，那么会产生编译时错误



## 默认域初始化

* 仅当类没有提供任何构造器的时候，系统才会提供一个默认的构造器（无参数构造器）
* 数值为0，布尔值为false，对象引用为null
* 必须明确地初始化方法中的局部变量，但是类中的域会自动初始化为默认值



## 初始化块

* 初始化数据域的方法
  * 在构造器中设置值
  * 在声明中赋值
  * 初始化块
* 建议将初始化块放在域定义的后面
* 调用构造器的具体处理步骤
  * 所有数据域被初始化为默认值
  * 按照在类声明中出现的次序，一次执行所有域初始化语句和初始化块
  * 如果构造器第一行调用了第二个构造器，则执行第二个构造器主体
  * 执行这个构造器的主体
* 可以使用静态的初始化块对类的静态域进行初始化
* 类第一次加载的时候，将会进行静态域的初始化
* 所有的静态初始化语句以及静态初始化块都将依照类定义的顺序进行



## 包（package）

* 所有标准的java包都处于java和javax包层次中
* 域名的逆序形式作为包名
* 嵌套的包之间没有任何关系

### 类的导入

* 一个类可以使用所属包中的所有类，以及其他包中的共有类
* 一种方式是在每个类名之前添加完整的包名
* 另一个种方式是使用import语句
  * 位于源文件的顶部，package后面
  * 只能使用星号（\*）导入一个包，而不能使用`import java.*` 或 `import java.*.*` 导入java为前缀的所有包
* C++中，必须用#include将外部特性的声明加载进来，这是因为C++编译器无法查看任何文件的内部，除了正在编译的文件以及在头文件中明确包含的文件，而java编译器可以查看其它文件的内部
  * java中，package与import类似于C++中的namespace和using

### 静态导入

* import不仅可以导入类，还可以导入**静态方法**和**静态域**

* 例如：

  ```java
  import static java.lang.System.*;
  
  out.println("----1------");    // 使用System的静态方法和静态域，不用类名
  ```

* 还可以导入特定的方法或域

  ```java
  import static java.lang.System.out;
  ```

### 将类放入包中

* 将包的名字放在源文件开头
* 没有package语句，则放置在默认包（default package）中，没有名字的包
* 编译器在变异源文件的时候不检查目录结构
  * 如果不依赖其他包，不会出现编译错误