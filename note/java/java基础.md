# java基础

## 数据类型

8种基本类型（primitive type）：

* 4种整型
  * byte
  * short
  * int
  * long
* 2种浮点类型
  * float
  * double
* 1种用于表示Unicode编码的字符单元的字符类型char
  * char
* 一种用于表示真值的boolean类型
  * boolean

### 整型

| 类型  | 存储需求 |                        取值范围                         |
| :---: | :------: | :-----------------------------------------------------: |
|  int  |  4字节   |     - 2 147 483 648 ~ 2 147 483 647（正好超过20亿）     |
| short |  2字节   |                    - 32 768 ~ 32 767                    |
| long  |  8字节   | - 9 223 372 036 854 775 808 ~ 9 223 372 036 854 775 807 |
| byte  |  1字节   |                       - 128 ~ 127                       |

* int类型最常用
* java中，所有的数值类型所占据的字节数量与平台无关
* 长整型数值有一个后缀L或l（如`40000000000L`）
* 十六进制前缀0x或0X，八进制前缀0，如 010 对应八进制的8，容易混淆，不建议使用
* java 7 开始，加上前缀0b或0B表示二进制，还可以为数字字面量加下划线，更易读（如 `0b1111_0100_0010_0100_0000` 或 `1_000_000`表示一百万），java编译器会去掉这些下划线
* java没有任何无符号形式的整型

### 浮点类型

|  类型  | 存储需求 |                         取值范围                          |
| :----: | :------: | :-------------------------------------------------------: |
| float  |  4字节   |      大约 +- 3.402 823 47E+38F（有效位数为 6~7 位）       |
| double |  8字节   | 大约 +- 1.797 693 134 862 315 70E+308（有效位数为 15 位） |

* 绝大部分程序采用double类型
* float类型的数值有一个后缀F或f，没有后缀F的浮点数值默认为double类型，也可以有后缀D或d
* 所有浮点数值计算都遵循 IEEE 754 规范，表示溢出和出错的三个特殊的浮点数值
  * 正无穷大：`Double.POSITIVE_INFINITY`
  * 负无穷大：`Double.NEGATIVE_INFINITY`
  * NaN（Not a Number）：`Double.NaN`
    * 不能检测一个特定值是否等于 `Double.NaN`
    * 可以使用 `Double.isNaN()`方法

### char类型

* char类型的字面量值要用单引号括起来
* 值可以表示为十六进制值，范围从 \u0000 到 \Uffff
* char类型描述了 UTF-16编码中的一个代码单元

### boolean类型

* 两个值：false 和 true
* **整型值和布尔值之间不能进行相互转换**



## 变量

* 声明一个变量之后，必须用赋值语句对变量进行显示初始化
* 在java中可以将声明放在代码中的任何地方
* 变量的声明尽可能地靠近变量第一次使用的地方
* 不区分变量的声明与定义



## 常量

* 利用关键字 **final**指示常量
  * 只能被赋值一次
  * 一旦赋值之后，就不能再更改了
  * 常量名使用全大写

* 利用关键字 **static final**设置一个类常量
  * 定义位于方法外部



## 类型转换

两个不同数值类型进行二元操作时，先要将两个操作数类型转换为同一种类型，然后再进行计算：

* 如果两个操作数中的一个是double类型，另一个操作数就会转换为double类型
* 否则，如果其中一个操作数是float类型，另一个操作数将会转换为float类型
* 否则，如果其中一个操作数是long类型，另一个操作数将会转换为long类型
* 否则，两个操作数都将被转换为int类型



## 位操作

`>>>`运算符会用0填充高位，`>>`运算符用符号位填充高位，不存在 `<<<`运算符



## 字符串

* java字符串就是**Unicode字符序列**
* java没有内置的字符串类型，而是在标准java类库中提供了一个预定义类
* 每个用双引号括起来的字符串都是String类的一个实例
* 不能修改java字符串中的字符，String类对象称为**不可变字符串**
  * 编译器可以让字符串共享
  * 通常只有字符串常量是共享的，而 `+` 或 `substring` 等操作产生的结果并不是共享的

### 子串

`substring(start, end);` 左闭右开

### 拼接

* java使用 `+` 号连接两个字符串
* 当一个字符串与一个非字符串的值进行拼接时，后者被转换成字符串
* `String.join()`方法可以实现多个字符串拼接，用一个定界符分隔
  * `String.join("/", "S", "M", "L");` => `S/M/L`

### 检测相等

* `s.equals(t)` 检测两个字符串是否相等
* `s.equalsIgnoreCase(t)` 检测两个字符串是否相等，不区分大小写
* `s.compareTo(t)` s在t前返回负值，相等返回0，s在t后返回正值
* 一定不要使用 `==`检测两个字符串是否相等，只能检测是否放在同一个位置


### 空串和Null串

* 空串 `“”` 是长度为0的字符串
  * 是一个java对象，有自己的**串长度（0）**和**内容（空）**
* null串表示目前没有任何对象与该变量关联
  * `if (str == null)` 检测一个字符串是否为null



## 控制流程

### 块作用域

块（即复合语句）：由一对大括号括起来的若干条简单的java语句

* 块确定了变量的作用域

* 一个块可以嵌套在另一块中

* **不能再嵌套的两个块中声明同名的变量，否则无法编译**

  ```java
  public static void main(String[] args){
      int n;
      //...
      {
          int k;
          int n;    // Error
          //...
      }
  }
  ```

### switch语句

case标签：

* 类型为 char， byte， short 或 int 的常量表达式
* 枚举常量
* 字符串字面量（java 7开始）

### 中断控制流程语句

java设计者将goto作为保留字，但实际上并没有打算在语言中使用它。

但是提供了一种 **带标签的break语句**，用于跳出多重嵌套的循环语句

* 标签必须放在希望跳出的最外层循环之前，并且必须紧跟一个冒号

  ```java
  Scanner in = new Scanner(System.in);
  int n;
  read_data:
  while(...){
      //...
      for(...){
          System.out.print("...");
          n = in.nextInt();
          if (n < 0)
              break read_data;
          // ...
      }
  }
  // this statement is executed immediately after the labeled break
  ...
  ```

* 可以将标签应用到任何语句中，甚至可以应用到if语句或者块语句中
* 只能跳出语句块，而不能跳入语句块



## 数组

数组是一种数据结构，用来存储同一类型值的集合。

两种形式声明数组：

* `int[] a;` 建议使用
* `int a[];`

声明数组后，并没有将a初始化为一个真正的数组，应该使用**new运算符**创建数组。

```java
int[] a = new int[100];
```

这条语句创建了一个可以存储100个整数的数组。

数组长度**不要求是常量**：`new int[n]`会创建一个长度为n的数组。

创建一个数组时：

* 数字数组的所有元素会初始化为0
* boolean数组的元素会初始化为false
* 对象数组的元素会初始化为null

** 数组一旦创建了，就不能再改变它的大小。**

创建数组对象并同时赋予初始值的简化书写形式，不需要调用new

```java
int[] a = { 2, 3, 4, 5, 6, 7 };
```

初始化一个**匿名数组**

```java
new int[] { 11, 12, 13, 14, 15, 16};
```

* 数组的大小就是初始值的个数
* 可以在不创建新变量的情况下重新初始化一个数组
* 允许数组长度为0， 数组长度为0和null不同
* java数组没有指针运算，不能通过 `数组名+1` 得到数组的下一个元素



`a.length` 

* 获得数组中的元素个数

`Arrays.toString(type[] a)` 

* 打印数组中的所有值

`Arrays.copyOf(type[] a, int length)` 

* 将一个数组的所有值拷贝到一个新数组中去，通常用于增加数组的大小

`Arrays.sort(type[] a)`

* 对数组进行排序，使用了**优化的快速排序**算法  



---



## 对象与类

* 实例域（instance field）：对象中的数据
* 状态（state）：对于每个特定的类实例（对象）都有一组特定的实例域值，这些值的集合就是和这个对象的当前状态

### 类之间的关系

* 依赖（uses-a）：一个类的方法操纵另一个类的对象
* 聚合（has-a）：类A的对象包含类B的对象
* 继承（is-a）：A继承B

### 对象变量与对象

```java
Date birthday = new Date();
```

birthday是对象变量，new Date() 构造了一个新对象

* 对象变量并没有实际包含一个对象，而仅仅引用一个对象
* 任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new操作符的返回值也是一个引用
* 显式地将对象变量设置为null，表示这个对象变量没有引用任何对象
* 局部变量不会自动地初始化为null，而必须通过调用new或将它们设置null进行初始化
* **所有的java对象都存储在堆中，所有的java对象都是在堆中构造的**





### 用户自定义类

* 文件名必须与public类的名字相匹配
* 在一个源文件中，只能有一个公有类，但可以有任意数目的非公有类

### 构造器

* 构造器与类同名
* 每个类可以有一个以上的构造器
* 构造器可以有0个、1个或多个参数
* 构造器没有返回值
* 构造器总是伴随着new操作一起调用
* 不要在构造器中定义与实例域重名的局部变量



## final实例域

* 构建对象时必须初始化这样的域
* 初始化后不能再对它进行修改
* 大都应用于**基本类型域**或**不可变类的域**
  * 可变的类使用final会造成混乱
  * final关键字只是表示对象变量不会再引用其他对象，但是这个对象可以更改



## 静态域

* 也称为类域
* 所有对象共享
* 属于类而不属于任何对象



## 静态常量

* 例如：`public static finale double PI = 3.14145926535897323846;`
* 可以通过类名直接获取，`Math.PI`
* 由于每个类对象都可以对公有域进行修改，所以不建议将域设计为public，但是final域却没问题，因为声明为final不可修改



## 静态方法

* 不能向对象实施操作的方法
* static是类方法，不属于某一个对象
* 没有this参数，this和super都是指向对象
* 不能访问实例域，可以访问自身类中的静态域
* 使用类名调用方法，也可以使用类下对象调用，但是不建议
* 使用静态方法的情况
  * 一个方法不需要访问对象状态，所需参数都是通过显示参数提供
  * 只需要访问类的静态域



## main方法

* 不对任何对象进行操作
  * 在启动程序时还没有任何一个对象，静态的main方法将执行并创建程序所需要的对象
* 每个类都可以有一个main方法，可以用于单元测试



## 方法参数

> 按值调用（call by value）：表示方法接收的是调用者提供的值
>
> 按引用调用（call by reference）：表示方法接收的是调用者提供的变量地址
>
> 一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值

* java采用**按值调用**
  * 方法不能修改传递给它的任何参数变量的内容
* 方法参数的类型
  * 基本数据类型（数字、布尔型）
  * 对象引用（按值传递）
* 方法参数的使用情况
  * 一个方法不能修改一个基本数据类型的参数（数值、布尔）
  * 一个方法可以改变一个对象参数的标志
  * 一个方法不能让对象参数引用一个新的对象



## 重载（overloading）

* 方法的**签名（signature）**
  * **方法名、参数类型**
  * **不包含返回类型**
* 多个方法有相同的名字、不同的参数，便产生重载
  * 也就是说重载需要签名不同，只是返回类型不同不算重载
* 重载解析（overloading resolution）
  * 编译器通过**各个方法给出的参数类型**与**特定方法调用所使用的值类型**进行匹配来挑选相应的方法，如果找不到匹配的参数，那么会产生编译时错误



## 默认域初始化

* 仅当类没有提供任何构造器的时候，系统才会提供一个默认的构造器（无参数构造器）
* 数值为0，布尔值为false，对象引用为null
* 必须明确地初始化方法中的局部变量，但是类中的域会自动初始化为默认值



## 初始化块

* 初始化数据域的方法
  * 在构造器中设置值
  * 在声明中赋值
  * 初始化块
* 建议将初始化块放在域定义的后面
* 调用构造器的具体处理步骤
  * 所有数据域被初始化为默认值
  * 按照在类声明中出现的次序，一次执行所有域初始化语句和初始化块
  * 如果构造器第一行调用了第二个构造器，则执行第二个构造器主体
  * 执行这个构造器的主体
* 可以使用静态的初始化块对类的静态域进行初始化
* 类第一次加载的时候，将会进行静态域的初始化
* 所有的静态初始化语句以及静态初始化块都将依照类定义的顺序进行



## 包（package）

* 所有标准的java包都处于java和javax包层次中
* 域名的逆序形式作为包名
* 嵌套的包之间没有任何关系

### 类的导入

* 一个类可以使用所属包中的所有类，以及其他包中的共有类
* 一种方式是在每个类名之前添加完整的包名
* 另一个种方式是使用import语句
  * 位于源文件的顶部，package后面
  * 只能使用星号（\*）导入一个包，而不能使用`import java.*` 或 `import java.*.*` 导入java为前缀的所有包
* C++中，必须用#include将外部特性的声明加载进来，这是因为C++编译器无法查看任何文件的内部，除了正在编译的文件以及在头文件中明确包含的文件，而java编译器可以查看其它文件的内部
  * java中，package与import类似于C++中的namespace和using

### 静态导入

* import不仅可以导入类，还可以导入**静态方法**和**静态域**

* 例如：

  ```java
  import static java.lang.System.*;
  
  out.println("----1------");    // 使用System的静态方法和静态域，不用类名
  ```

* 还可以导入特定的方法或域

  ```java
  import static java.lang.System.out;
  ```

### 将类放入包中

* 将包的名字放在源文件开头
* 没有package语句，则放置在默认包（default package）中，没有名字的包
* 编译器在变异源文件的时候不检查目录结构
  * 如果不依赖其他包，不会出现编译错误



---



## 继承

* 在Java中，所有的继承都是公有继承
* super不是一个对象的引用，不能将super赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字
* 子类中可以增加域、增加方法或覆盖方法，但是不能删除继承的任何域和方法
* super调用构造器的语句必须是子类构造器的第一条语句
  * 如果子类的构造器没有显式的调用超类的构造器，则将自动的调用超类默认构造器
  * 如果超类没有默认构造器，并且在子类构造器中又没有显式的调用超类的其他构造器，则Java编译器将报告错误

### 多态

> **多态（polymorphism）：**一个对象变量可以指示多种实际类型的现象

* 置换法则（is-a规则)：出现超类对象的任何地方都可以用子类对象置换
  * 例如，可以将一个子类对象赋给超类变量，但是不能将一个超类的引用赋给子类变量
* 对象变量是多态的

* **动态绑定（dynamic binding）：**在运行时能够自动的选择调用哪个方法的现象
  * 特性：无需对现存的代码进行修改，就可以对程序进行扩展
* 覆盖方法的时候，子类方法可见性不能低于超类方法，即子类方法不能更严格

### 理解方法调用

1. 编译器查看对象的**声明类型**和**方法名**，查找隐式参数类及其父类中可访问的所有该方法名的方法
2. 编译器查看调用方法时提供的**参数类型**，如果在所有名对应的方法中存在一个与提供的参数类型完全匹配，就选择这个方法，这个过程叫**重载解析（overloading resolution）**
3. 如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，就会报告一个错误
   * 覆盖方法时，一定要保证返回类型的兼容性，允许子类将覆盖方法的返回类型定义为原返回类型的子类型，称这两个方法具有可协变的返回类型
4. **静态绑定（static binding）**：如果是private方法、static方法、final方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法
5. **动态绑定**，调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。采用动态绑定调用方法时，虚拟机一定调用与隐式参数所引**用对象实际类型最合适**的那个类的方法
   * 先找当前类，再找超类

* **方法表（method table）：**列出了所有方法的签名和实际调用的方法
  * 避免时间开销过大
  * 每个类都有方法表

### final类和方法

* final类不能继承
* final方法不能覆盖
* 如果一个类声明为final，只有其中的方法自动成为final，而不包括域

### 强制类型转换

> **类型转换：**将一个类型强制转换成另外一个类型的过程

* 用一对圆括号将目标类名括起来，并放置在需要转换的对象引用之前即可
* 类型转换的原因：暂时忽视对象的实际类型，使用对线的全部功能
* 只能在继承层次内进行类型转换
* 在将超类转换成子类之前，应该使用instanceof进行检查（向下转换）

### 抽象类

* 关键字：abstact
* 包含一个或多个抽象方法的类本身必须声明为抽象的
* 抽象类可以包含具体数据和方法
* 扩展抽象类时
  * 可以实现部分方法，但是需要声明为抽象类
  * 也可以实现全部方法，无需声明为抽象类
* 类即使不含抽象方法，也可以声明为抽象类
* 抽象类不能被实例化
* 可以定义一个抽象类的对象变量，但是只能引用非抽象子类的对象

### 访问修饰符

| 修饰符  |  类  |  包  | 子类 | 其他包 |
| :-----: | :--: | :--: | :--: | :----: |
| public  |  ✔   |  ✔   |  ✔   |   ✔    |
| protect |  ✔   |  ✔   |  ✔   |   ✘    |
| default |  ✔   |  ✔   |  ✘   |   ✘    |
| private |  ✔   |  ✘   |  ✘   |   ✘    |



## Object：所有类的超类

* Object类是Java中所有类的始祖，在Java中每个类都是由它扩展而来的
* 可以使用Object类型的变量引用任何类型的对象
* 只有基本类型不是对象，所有的数组类型都扩展了Object类

### equals方法

> 用于检测一个对象是否等于另外一个对象

* 源码：

  ```java
  public boolean equals(Object obj) {
     return (this == obj);
  }
  ```

* Object中的equals用`==`实现，判断两个对象是否具有相同的引用

* 具体类使用时，需要重写equals方法

### hashcode方法

* **散列码（hash code）**
  * 由对象导出的一个整型值
  * 没有规律
* 由于hashCode方法定义在Object类中，所以每个对象都有一个默认的散列码，值为**对象的存储地址**
* 如果重新定义equals方法，就必须重新定义hashCode方法，以便用户可以将对象插入到散列表中
* Equals与hashCode的定义必须一致：如果x.equals(y)返回true，那么x.hashCode()就必须与y.hashCode()具有相同的值

### toString方法

> 返回表示对象值的字符串

* 只要对象与一个字符串通过操作符“+”连接起来，java编译就会自动的调用toString方法
  * 在调用x.toString()的地方可以用“+”替代，如果x是基本类型，一样可以执行
* Object类定义了toString方法，用来打印输出**对象所属的类名**和**散列码**
* 打印数组：`Arrays.toString()`，多维数组：`Arrays.deepToString()`



## 对象包装器与自动装箱

* 所有基本类型都有一个与之对应的类，这些类称为包装器（wrapper）
  * Integer、Long、Float、Double、Short、Byte、Character、Void、Boolean
* 对象包装器类是不可变的，一旦构造了包装器，就不允许更改包装在其中的值
* 对象包装器是final，不能定义子类

```java
Array<Integer> list = new ArrayList<>();

list.add(3);
// 上句将自动变换成
list.add(Integer.valueOf(3));
```

* 这种变换称为**自动装箱（autoboxing）**

```java
int n = list.get(i);
// 转换为
int n = list.get(i).intValue();
```

* 这种变换称为**自动拆箱**
* 装箱和拆箱是**编译器**认可的，而不是虚拟机
  * 编译器在生成类的字节码文件事，插入必要的方法调用，虚拟机只是执行这些字节码



## 参数数量可变的方法

* 自Java SE 5.0以来，提供了可变参数数量调用的方法（变参方法）

* printf方法定义如下：

  ```java
  public class PrintStream{
      public PrintStream printf(String fmt, Object... args){
      	return format(fmt, args);
      }
  }
  ```

* 省略号表示这个方法可以接受任意数量的参数

* Object...参数和Object[]完全一样

* 可以自己定义可变参数的方法，参数可以指定为任意类型，甚至是基本类型

* 允许将一个数组传递个可变参数方法的最后一个参数

  ```java
  // main可以声明为以下形式
  public static void main(String... args)
  ```



## 枚举类





---



## 接口

* 接口不是类，而是对类的一组需求描述
* 接口中的所有方法自动属于public，在接口中声明方法时，不必提供关键字public
* 接口中绝不能含有实例域，java se 8开始，可以在接口中提供简单方法
* 实现接口的步骤：
  1. 将类声明为实现给定的接口
  2. 对接口中所有方法进行定义
* 接口中所有方法自动是public，但是**在实现接口时，必须把方法声明为public**，否则，编译器会提示更严格的访问权限
* 接口不是类，不能使用new运算符实例化一个接口
* 不能构造接口的对象，但是能声明接口的变量，接口变量必须引用实现了接口的类对象
* 可以使用instanceof检查一个对象是否实现了某个特定的接口
* 接口可以扩展，允许存在多条从具有较高通用性的接口到较高专用性的接口的链
* 接口中不能包含实例域或静态方法，但是可以包含常量，接口中的域自动设为`public static final`
* 每个类只能有一个超类，但却可以实现多个接口，使用逗号将实现的各个接口分隔开

### 静态方法

* java se 8中，允许在接口中增加静态方法
* 通常的做法都是将静态方法放在**伴随类**中
  * 标准库中成对出现的接口和实用工具类，如Collection/Collections, Path/Paths

### 默认方法

* 可以为接口方法提供一个默认实现，必须用**default修饰符**标记这样一个方法

  ```java
  public interface Comparable<T>{
      default int compareTo(T other){
          return 0;
      }
  }
  ```

* 可以实现自己需要的，而不用实现一些不需要使用的

* 默认方法可以调用任何其他方法

* 很多接口都有相应的伴随类，实现了相应接口的部分或所有方法，如Collection/AbstractCollection或MouseListener/MouseAdapter，在java se 8中，这个技术已经过时，现在可以直接在接口中实现方法

* **接口演化（interface evolution）**：为接口增加方法时，设为default，可以不用修改实现类

### 默认方法冲突

在接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了一个同样的方法，规则如下：

1. **超类优先**。如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略
   * 类优先规则，保证了与java se 7的兼容性，如果为一个接口增加默认方法，这对于之前正常工作的代码没有任何影响
   * 不要让一个默认方法重新定义Object类中的某个方法，由于类优先规则，这样的方法永远不能超越Object的方法
2. **接口冲突**。如果一个超接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型相同的方法，**必须覆盖这个方法解决冲突**
   * 如果至少有一个接口提供了一个实现，编译器就会报错



