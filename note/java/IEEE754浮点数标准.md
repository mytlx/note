# IEEE 754浮点数标准

计算机发展过程中，曾提出过许多种实数的表示方法，比如相对于浮点数的**定点数（Fixed Point Number）。**

在**定点数**表达法中，小数点固定于所有数字间的某一位置上，**固定的小数点位置决定了整数位数和小数位数**，不利于表达特别大或特别小的数。由此，浮点数表达法盛行。

**浮点数表示法**采用了**科学计数法**表达实数，即用一个**有效数字**、**一个基数（base）**、**一个指数（Exponent）**及一个表示**正负的符号**来表达实数。比如，12.34用十进制计数法可以表示为 $1.234 \times 10^1$（其中，1.234为有效数字，10为基数，1为指数）。浮点数**利用指数达到了浮动小数点的效果**，从而可以灵活地表达更大范围的实数。

仅做如上规定会产生无数种表达方式，最终都需要规范到如下形式：

$$ \qquad\color{red}{\pm d.dd···d \times\beta ^e (0 \leq d_i < \beta)}​$$ 

其中，d.dd···d为有效数字，$\beta$为基数，e为指数。

## 浮点数表示法

直到 20 世纪 80 年代（即在没有制定 IEEE 754 标准之前），业界还没有一个统一的浮点数标准。相反，很多计算机制造商根据自己的需要来设计自己的浮点数表示规则，以及浮点数的执行运算细节。另外，他们常常并不太关注运算的精确性，而把实现的速度和简易性看得比数字的精确性更重要，而这就给代码的可移植性造成了重大的障碍。

直到 1976 年，Intel 公司打算为其 8086 微处理器引进一种浮点数协处理器时，意识到作为芯片设计者的电子工程师和固体物理学家也许并不能通过数值分析来选择最合理的浮点数二进制格式。于是，他们邀请加州大学伯克利分校的 William Kahan 教授（当时最优秀的数值分析家）来为 8087 浮点处理器（FPU）设计浮点数格式。而这时，William Kahan 教授又找来两个专家协助他，于是就有了 KCS 组合（Kahn、Coonan和Stone），并共同完成了 Intel 公司的浮点数格式设计。

由于 Intel 公司的 KCS 浮点数格式完成得如此出色，以致 IEEE（Institute of Electrical and Electronics Engineers，电子电气工程师协会）决定采用一个非常接近 KCS 的方案作为 IEEE 的标准浮点格式。于是，IEEE 于 1985 年制订了二进制浮点运算标准 IEEE 754（IEEE Standard for Binary Floating-Point Arithmetic，ANSI/IEEE Std 754-1985），该标准限定指数的底为 2，并于同年被美国引用为 ANSI 标准。目前，几乎所有的计算机都支持 IEEE 754 标准，它大大地改善了科学应用程序的可移植性。

考虑到 IBM System/370 的影响，IEEE 于 1987 年推出了与底数无关的二进制浮点运算标准 IEEE 854，并于同年被美国引用为 ANSI 标准。1989 年，国际标准组织 IEC 批准 IEEE 754/854 为国际标准 IEC 559：1989。后来经修订后，标准号改为 IEC 60559。现在，几乎所有的浮点处理器完全或基本支持 IEC 60559。同时，C99 的浮点运算也支持 IEC 60559。  

**IEEE 浮点数标准**是从逻辑上用 **三元组{S，E，M}** 来表示一个数 V 的，即 $V=(-1)^S×M×2^E$。

![浮点数1.png](https://github.com/mytlx/note/blob/master/note/java/img/%E6%B5%AE%E7%82%B9%E6%95%B01.png?raw=true)

* 符号位（sign）：s=0，正数；s=1，负数。对于数值0的符号位特殊情况处理
* 指数位（exponent）：2的幂（可正可负），对浮点数加权
* 有效数字位（mantissa）：二进制小数，也称为尾数位，系数位，或称为”小数“

根据exp的值，可分为以下几种情况：

#### 1. 格式化值

当指数段 exp 的位模式既不全为 0（即数值 0），也不全为 1（即单精度数值为 255，以单精度数为例， 8 位的指数为可以表达 0~255 的 255 个指数值；双精度数值为 2047）的时候，就属于此情况。

指数既要表示正数，又要表示负数，为了处理负数的情况，需要在实际指数值上加一个**偏置值（Bias）**作为保存在指数段中的值。

这种情况下的指数段被解释为以偏置形式表示的有符号整数。即指数的值为：$E = e - Bias$，

其中，e是无符号数，Bias是$2^k -1$（单精度127，双精度1023）

由此产生的指数范围：

* 单精度：-126 ~ 127
* 双精度：-1022 ~1023

对小数段 frac，可解释为描述小数值 f，其中 $0≤f<1$，其二进制表示为$ 0.f_{n-1}…f_1f_0$，也就是二进制小数点在最高有效位的左边。有效数字定义为 $M=1+f$。

有时候，这种方式也叫作**隐含的以 1 开头的表示法**，因为我们可以把 M 看成一个二进制表达式为$ 1.f_{n-1}f_{n-2}…f_0$ 的数字。既然我们总是能够调整指数 E，使得有效数字 M 的范围为 $1≤M<2$（假设没有溢出），那么这种表示方法是一种轻松获得一个额外精度位的技巧。同时，**由于第一位总是等于 1，因此我们就不需要显式地表示它。**

拿单精度数为例，按照上面所介绍的知识，实际上**可以用 23 位长的有效数字来表达 24 位的有效数字**。

比如，对单精度数而言，二进制的 1001.101（即十进制的 9.625）可以表达为 1.001101×23，所以实际保存在有效数字位中的值为：$001\,1010\,0000\,0000\,0000\,0000$，即**去掉小数点左侧的 1，并用 0 在右侧补齐**。

将-9.625转换为单精度浮点数格式的步骤：

1. 首先，需要将 -9.625 用二进制浮点数表达出来，然后变换为相应的浮点数格式。即 -9.625 的二进制为 $1001.101$，用规范的浮点数表达应为$1.001101×2^3$
2. 其次，因为 -9.625 是负数，所以符号段为 1。而这里的**指数为 3**，所以**指数段**为 $3+127=130$，即二进制的 $1000\,0010$。有效数字省略掉小数点左侧的 1 之后为$ 001\,101$，然后在右侧用零补齐。因此所得的最终结果为：$1\mid1000\,0010\mid001\,1010\,0000\,0000\,0000\,0000$
3. 最后，我们还可以将浮点数形式表示为十六进制的数据：$0xC11A0000$

#### 2. 特殊数值

IEEE 标准指定了以下特殊值：$±0$、反向规格化的数、$±\infty$ 和 NaN。这些特殊值都是使用 $e_{max}+1$或$ e_{min}-1 $的指数进行编码的。

|             指数             | 尾数部分 |          表示          |
| :--------------------------: | :------: | :--------------------: |
|       $ e= e_{min}-1 $       |  $f=0$   |         $\pm0$         |
|        $e= e_{min}-1$        | $f\neq0$ | $0.f\times2^{e_{min}}$ |
| $e_{min}\leq e \leq e_{max}$ |   $-$    |     $1.f\times2^e$     |
|        $e=e_{max}+1$         |  $f=0$   |      $\pm\infty$       |
|        $e=e_{max}+1$         | $f\neq0$ |          NaN           |

* 指数段全是0，尾数部分全是0，表示$\pm0$
* 指数段全是1，尾数部分不为0，表示**NaN（Not a Number）**
* 指数段全是1，尾数部分全是0，表示**无穷**

按照传统，将$0/0$或$\sqrt{-1}$视为导致计算终止的不可恢复的错误，但是存在一些情况下，表明这样的计算是有意义的，由此引入了NaN，对于这些计算结果生成NaN而不是停止运行。

通常，每当NaN参与浮点数运算时，结果都是另一NaN

* 产生NaN的运算

|     操作     |     产生NaN的表达式     |
| :----------: | :---------------------: |
|     $+$      |  $\infty + (-\infty)$   |
|     $.$      |       $0.\infty$        |
|     $/$      |  $0/0, \infty/\infty$   |
|    $REM$     | $x REM 0, \infty REM y$ |
| $\sqrt\quad$ |  $\sqrt{x}（当x<0时）$  |

#### 3. 非格式化值

如果有效数字域的位是$b_1,b_2,...,b_{p-1}$，且指数的值是e，那么当$e>e_{min}-1$时，所表示的数是$1.b_1b_2...b_{p-1}\times2^e$（使用隐藏位1），当$e=e_{min}-1$时，所表示的数是$0.b_1b_2...b_p\times\color{red}{2^{e+1}}$（不使用隐藏位），指数中的的+1是必需的，因为反向规格数的指数是$e_{min}$，而不是$e_{min}-1$

简单来说，当指数段 exp 全为 0 时，所表示的数就是非规格化形式。

在这种情况下，指数值 $\color{red}{E=1-Bias}$，而有效数字的值 **M=f**，也就是说它是小数段的值，不包含隐含的开头的 1。

非规格化值有两个用途：

1. 它提供了一种**表示数值 0** 的方法。因为规格化数必须得使有效数字 M 在范围 1≤M<2 之中，即 M≥1，因此它就不能表示 0。当符号位为0，而其他段全为 0 时，就会得到值 +0.0。当符号位为 1，而其他段全为 0 时，就会得到值 -0.0。根据 IEEE 的浮点格式来看，值 +0.0 和 -0.0 在某些方面是不同的。

2. 它表示那些**非常接近于 0.0 的数**。它们提供了一种属性，称为**渐进下溢**。其中，可能的数值分布均匀地接近于 0.0。

##### 渐进下溢

以$\beta=10, p=3, e_{min}=-98$为例。

**对于正规浮点数**，

数$x = 6.87\times10^{-97}$和$y = 6.81\times10^{-97}$ 有一个奇怪的属性，$x - y = 0$，虽然$x \neq y$，原因是：

$x-y=0.06\times10^{-97}=6.0\times10^{-99}$太**小以致于无法表示为规格化数，因此必须清零**。

**而对于反向规格化数**，

$x-y$ **不清零**，而改为由反向规格化数$0.6\times10^{-98}$来表示，这种行为称为**渐进下溢**



格式化值和非格式化值所能表达的范围如下:

![格式化和非格式化范围.png](https://github.com/mytlx/note/blob/master/note/java/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%92%8C%E9%9D%9E%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%8C%83%E5%9B%B4.png?raw=true)



## 标准浮点格式

IEEE 754标准准确地定义了单精度和双精度浮点格式，并为这两种基本格式分别定义了扩展格式，如下所示：

- 单精度浮点格式（32 位）。
- 双精度浮点格式（64 位）。
- 扩展单精度浮点格式（≥43 位，不常用）。
- 扩展双精度浮点格式（≥79 位，一般情况下，Intel x86 结构的计算机采用的是 80 位，而 SPARC 结构的计算机采用的是 128 位）。

其中，只有 32 位单精度浮点数是本标准强烈要求支持的，其他都是可选部分。下面就来对单精度浮点与双精度浮点的存储格式做一些简要的阐述。

#### 1. 单精度浮点数格式

单精度浮点数格式共32位，其中，s、exp、frac段分别占1bit，8bits，23bits

![32位.png](https://github.com/mytlx/note/blob/master/note/java/img/32%E4%BD%8D.png?raw=true)

其中，32 位中的第 0 位存放小数段 frac 的最低有效位 LSB（least significant bit），第 22 位存放小数段 frac 的最高有效位 MSB（most significant bit）；第 23 位存放指数段 exp 的最低有效位 LSB，第 30 位存放指数段 exp 的最高有效位 MSB；最高位，即第 31 位存放符号 s。

#### 2. 双精度浮点数格式

双精度浮点格式共 64 位，其中，s、exp、frac 段分别占1bit，11bits，52bits

![64位.png](https://github.com/mytlx/note/blob/master/note/java/img/64%E4%BD%8D.png?raw=true)

其中，frac[31：0] 存放小数段的低 32 位（即第 0 位存放整个小数段的最低有效位 LSB，第 31 位存放小数段低 32 位的最高有效位 MSB）；frac[51：32] 存放小数段的高 20 位（即第 32 位存放高 20 位的最低有效位 LSB，第 51 位存放整个小数段的最高有效位 MSB）；第 52 位存放指数段 exp 的最低有效位 LSB，第 62 位存放指数段 exp 的最高有效位 MSB；最高位，即第 63 位存放符号 s。



### 舍入误差

舍入误差是指运算得到的近似值和精确值之间的差异。由于计算机字长有限，计算过程中，会对数据求取近似值，而这导致计算结果产生误差。

在浮点数的舍入问题上，IEEE 浮点格式定义了 4 种不同的舍入方式，如下表所示。其中，默认的舍入方法是向**偶数舍入**，而其他三种可用于计算上界和下界。

|   名  称   |                           描  述                           |
| :--------: | :--------------------------------------------------------: |
| 向偶数舍入 | 也称为向最接近值的舍入，会将结果舍入为最接近且可以表示的值 |
|  向0 舍入  |                   会将结果朝0的方向舍入                    |
|  向上舍入  |       向$+\infty$舍入，会将结果朝正无穷大的方向舍入        |
|  向下舍入  |       向$-\infty$舍入，会将结果朝负无穷大的方向舍入        |

下表是应用举例，向偶数舍入（向最接近值的舍入）会找到一个最接近的值，对于该位是5的，向偶数方向舍入

| 名称 \ 值  | 1.4  | 1.5  | 1.6  | 2.5  | -1.5 |
| :--------: | :--: | :--: | :--: | :--: | :--: |
| 向偶数舍入 |  1   |  2   |  2   |  2   |  -2  |
|  向0 舍入  |  1   |  1   |  1   |  2   |  -1  |
|  向上舍入  |  2   |  2   |  2   |  3   |  -2  |
|  向下舍入  |  1   |  1   |  1   |  2   |  -1  |

#### 为什么使用向偶数舍入，而不是四舍五入？

在进行舍入的时候，最后一位数字从 1 到 9，舍去的有 1、2、3、4；它正好可以和进位的 9、8、7、6 相对应，而 5 却被单独留下。如果我们采用四舍五入每次都将 5 进位的话，在进行一些大量数据的统计时，就会累积比较大的偏差。而如果采用向偶数舍入的策略，在大多数情况下，5 舍去还是进位概率是差不多的，统计时产生的偏差也就相应要小一些。

由IEEE浮点格式定义的舍入方式可知，不论使用哪种舍入方式，都会产生舍入误差。如果在一系列运算中的一步或几步产生了舍入误差，在某些情况下，这个误差将会随着运算次数的增加而积累得很大，最终会得出没有意义的运算结果。因此，建议不要将浮点数用于精确计算。



参考：https://wenku.baidu.com/view/11d8f46527d3240c8447efa8.html