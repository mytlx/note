## 初级排序算法



### 选择排序

> 找到数组中最小的那个元素，将它和数组的第一个元素交换位置。

* 每次都能排定一个元素，所以交换的总次数是N，时间效率取决于**比较的次数**
* 特点：
  * **运行时间和输入无关：**上次扫描不能为下次提供有用的信息，无论数组是否有序，排序时间都是一样长
  * **数据移动是最少的：**交换次数和数组大小是线性关系

```java
/**
 * 将a[]升序排列
 * @param a
 */
public static void sort(Comparable[] a) {
    int N = a.length;
    for (int i = 0; i < N; i++) {
        //将a[i]和a[i+1...N]中最小的元素交换
        int min = i;
        for (int j = i + 1; j < N; j++) {
            if (less(a[i], a[min])) {
                min = j;
            }
        }
        exch(a, i, min);
    }
}
```



### 插入排序

> 一个一个来，将每个元素插入到其他已经有序的牌中的适当位置。

* 排序所需时间取决于**输入中元素的初始顺序**
* **倒置：**数组中的两个顺序颠倒的元素
  * 如果数组中倒置的数量小于数组大小的某个倍数，那么我们说和这个数组是**部分有序**的
* 当**倒置的数量很少**时，插入排序可能比其他算法都快

* $令倒置数量为m，则：$

  $比较次数(x)：m \le x \le m+N-1$

  $交换次数(y)：y = m$

* 总的来说：
  * 插入排序对于**部分有序**的数组十分高效，也很适合小规模数组



```java
public static void sort(Comparable[] a) {
    int n = a.length;
    for (int i = 1; i < n; i++) {
        for (int j = i; j > 0 && less(a[j], a[j - 1]); j--) {
            exch(a, j, j - 1);
        }
    }
}
```



### 希尔排序（基于插入排序的快速的排序算法）

> 交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将局部有序的数组排序

* 思想：使数组中任意间隔为h的元素都是有序的，称为**h有序数组**
  * 一个h有序数组就是h个互相独立的有序数组编织在一起组成的一个数组
* 实现希尔排序的一种方法：
  * 对于每个h，用插入排序将h个子数组独立地排序
  * 也就是在h-子数组中将每个元素交换到比它大的元素之前去
  * 类似于插入排序但使用不同增量的过程
* 希尔排序也可以用于**大型数组**，对任意排序的数组都可以

```java
public static void sort(Comparable[] a) {
    int N = a.length;
    int h = 1;
    while (h < N / 3) h = 3 * h + 1;
    while (h >= 1) {
        for (int i = h; i < N; i++) {
            for (int j = i; j >= h && less(a[j], a[j - h]); j -= h) {
                exch(a, j, j - h);
            }
        }
        h = h / 3;
    }
}
```













